# ЗАДАНИЕ

> Перед выполнением нужно локально все установить, как описано в "Старт" и "Первый запуск".  

## 0. Технологии и подход
- Laravel 8
- MySQL 8
- PHP 7.4
- Redis
- Docker & Docker-compose
- Nginx/php-fpm/phpmyadmin

При выполнении задания считается нормальным (и приветствуется) активно пользоваться google и stackoverflow.  
Также рекомендуется использовать библиотеки для решения стандартных вопросов.  

Предварительно установлено несколько стандартных (де-факто) библиотек:  
- barryvdh/laravel-debugbar
- barryvdh/laravel-ide-helper
- laravel/horizon
- laravel/passport
- intervention/image
- laracasts/utilities

## 1. Вводное
Задание состоит в написании API для возвращения информации (Faker) о сериале Breaking Bad.  

Имеются такие основные сущности:  
1. User - дефолтная моделька без кастомных полей, используется для доступа к API (Level 2).  
2. Episode - эпизод сериала (с краткой информацией).  
3. Character - персонаж, который связан с эпизодами и цитатами.  
4. Quote - цитата персонажа, связана с эпизодом.  

## 2. Level 1
### 2.1. Миграции/модели
**Episode:**  
id int  
title string Название  
air_date date Дата выхода  

Связан с персонажами как многие-ко-многим.  
Связан с цитатами как один-ко-многим.  

**Character:**  
id int  
name string Имя  
birthday date Дата рождения  
occupations json Профессии/умения  
img string Фото  
nickname string Известен как (кличка)  
portrayed string Актер, сыгравший персонажа  

Связан с цитатами как один-ко-многим.  

**Quote:**  
id int  
quote mediumtext Цитата  

### 2.2 Сидеры
Написать сидеры, чтобы заполнили БД тестовыми данными на основе Faker-а.  
30 эпизодов, 100 персонажей и ~500 цитат. На 1 эпизод по 5-15 персонажей, на 1 персонажа по 3-7 цитат.  

### 2.3 Написать API для отдачи базовых данных
> API должно быть доступно по `https://laravel-test.com/api/`.  

**Endpoints:**  
/episodes - отдает все эпизоды  
/episodes/{id} - отдает эпизод по ID (с персонажами: информацией)  
/characters - отдает всех персонажей (с ID эпизодов и ID цитат)  
/character/random - отдает рандомного персонажа  
/characters?name={name} - поиск по имени персонажа (регистронезависимый)  
/quotes - отдает все цитаты  
/quote/random?author={character_name} - рандомная цитата персонажа с поиском по имени персонажа  

**Базовые правила API**:  
коды ответов - 200, 401, 403, 404, 429, 500 (:D)  
структура ответа:  
```
{
    "success": true, // или false, если ошибка
    "data": null | {} || [], // в случае success-ответа
    "pagination": { // данные пагинации при получении "списков"
        "total": 0, // общее количество сущностей
        "count": 0, // сколько отдано в текущем запросе
        "perPage": 0, // сколько на странице
        "currentPage": 0, // текущая страница
        "totalPages": 0 // всего страниц
    },
    "error": { // в случае error-ответа
        "message": null | "" 
    }
}
```
при запросе списков можно передавать limit (default=10) и page (default=1), чтобы пагинировать.  

> Рекомендуется использовать библиотеку flugger/laravel-responder.  

## 3. Level 2
### 3.1 Простая регистрация и авторизация
Реализовать максимально простой интерфейс (bootstrap/etc) регистрации/авторизации (без каких-либо восстановить пароль и пр.) дефолтной модели юзера.  
Не нужно подтверждение мейла (как и отправка).  

### 3.2 Выдача токенов доступа к API
Закрыть публичный доступ к API (п. 2.3), требовать `auth:api`.  
Сделать максимально простую страницу, которая бы менеджерила токены доступа при помощи Laravel Passport. [Вот Personal Access Tokens](https://laravel.com/docs/8.x/passport#personal-access-tokens).  

### 3.3 Лимиты API
Установить лимит запросов к API для одного юзера равный 20/min.  

## Extra
При каждом запросе к API запускать событие ApiRequestHit (private time, user).  
Обработчик должен инкрементировать при помощи [Cache](https://laravel.com/docs/8.x/cache) скажем в *api:users:{id}*.  
Создать запланированную задачу (schedule) с периодом 1 минута, которая будет выполняться в очереди и считать общее к-во запросов к API и складировать это в кеш (Redis) *api-total-requests*.  
Запрос к endpoint-у `/stats` выдаст общее количество запросов.  
Запрос к endpoint-у `/my-stats` выдаст количество запросов текущего юзера.  

PS. Подсказка по работе с Redis:  
```
use Illuminate\Support\Facades\Redis;
$redis = Redis::connection('cache'); // получение соединения (кеша) редиса

$redis->keys('api:users:*'); // получение всех ключей по шаблону (юзеров)
$prefix = config('database.redis.options.prefix'); // все ключи вернутся с префиксом, его нужно удалить, прежде чем запросить данные с кеша
```
